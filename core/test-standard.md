# Test Standards

テストコードの書き方、網羅性の基準、TDD原則に関する共通ルールです。

## 概要

このルールは、テスト駆動開発（TDD）の原則、テストカバレッジ要件、テスト戦略の根本原則を定義します。品質の高いコードを維持するための基本原則です。

## 基本原則

### 1. テスト駆動開発（TDD）の推奨

**TDDサイクル**:
1. **Red**: 失敗するテストを書く
2. **Green**: テストを通す最小限のコードを書く
3. **Refactor**: コードを改善し、テストを維持する

**TDDの実装ルール**:
- 新機能開発時は必ずテストから開始
- バグ修正時は再現テストを先に作成
- テストが通るまで実装を進める
- リファクタリング時はテストを維持

### 2. テスト戦略の根本原則

**🚨 重要なテスト戦略の原則**:

**1. 実装優先アプローチ**
- **モック作成は最後の手段**: まず実装の動作確認を優先
- **実際の依存関係の活用**: 可能な限り実際のサービスを使用
- **段階的なテスト**: 単体 → 統合 → E2Eの順序で実行

**2. モック作成の判断基準**
- **技術的制約の確認**: 外部API、データベース等の制約を事前に調査
- **既存実装の確認**: 過去の実装でモックが不要な場合を確認
- **代替手段の検討**: ローカル環境、テストデータ等の活用

**3. テスト実行の阻害要因の回避**
- **複雑なモックの回避**: シンプルで理解しやすいテスト構造
- **実装の動作確認**: モック作成前に実装の動作を確認
- **段階的なアプローチ**: 小さなステップで確実に進める

**4. 要件と前提の確認**
- **実装者への確認**: 不明な仕様や前提は必ず確認
- **技術的制約の調査**: 外部依存関係の制約を事前に把握
- **代替手段の検討**: モック以外の解決策を検討

### 3. テストカバレッジ要件

**最小カバレッジ**:
- **全体**: 80%以上
- **クリティカルパス**: 100%
- **ビジネスロジック**: 90%以上
- **ユーティリティ**: 80%以上

**カバレッジの測定**:
- カバレッジレポートを自動生成
- CI/CDでカバレッジ閾値を強制
- カバレッジの傾向を監視

### 4. テストの種類

**単体テスト**:
- 各関数・クラスの個別テスト
- 依存関係をモック化
- 高速に実行可能

**統合テスト**:
- コンポーネント間の連携テスト
- データベース接続テスト
- 外部API連携テスト

**E2Eテスト**:
- 完全なユーザーフローのテスト
- 実際の環境での動作確認
- データの整合性チェック

**パフォーマンステスト**:
- レスポンス時間の測定
- メモリ使用量の監視
- 負荷テストの実施

## 具体的な指針

### テストの構造

**テストファイルの構造**:
```typescript
describe('ComponentName', () => {
  describe('methodName', () => {
    it('should expected behavior when condition', () => {
      // Arrange: テストデータの準備
      const input = { /* ... */ };
      
      // Act: テスト対象の実行
      const result = component.methodName(input);
      
      // Assert: 結果の検証
      expect(result).toBe(expected);
    });
  });
});
```

**テストの命名規則**:
- `describe`: テスト対象の説明
- `it`: 期待される動作の説明
- 明確で理解しやすい説明文

### テストデータの管理

**テストデータの作成**:
```typescript
// ✅ 良い例：テストデータを明確に定義
const mockUser: User = {
  id: 'user-1',
  name: 'Test User',
  email: 'test@example.com',
  createdAt: new Date('2024-01-01')
};
```

**テストデータの再利用**:
- テストヘルパー関数を作成
- ファクトリーパターンを活用
- テストデータを一元管理

### モックの使用

**モック作成の判断フロー**:
```
実装の動作確認
    ↓
技術的制約の調査
    ↓
既存実装の確認
    ↓
代替手段の検討
    ↓
モック作成（最後の手段）
```

**モックのベストプラクティス**:
- シンプルで理解しやすいモック構造
- 実装の動作確認後にモックを作成
- 必要最小限のモック化

### テストの実行

**テスト実行のタイミング**:
- **開発中**: 各機能実装後に単体テスト実行
- **コミット前**: 全テストスイート実行
- **プルリクエスト前**: 統合テストとE2Eテスト実行
- **デプロイ前**: パフォーマンステスト実行

**テスト実行コマンド**:
```bash
# 全テスト実行
npm test

# カバレッジ付きテスト実行
npm test -- --coverage

# 特定のテストファイル実行
npm test -- path/to/test.ts

# ウォッチモード
npm test -- --watch
```

## テストスクリプト管理

**テストスクリプトの組織化**:
```
test-script/
├── unit/              # 単体テストスクリプト
├── integration/       # 統合テストスクリプト
├── e2e/              # エンドツーエンドテスト
├── performance/      # パフォーマンステスト
└── utils/            # テストユーティリティ
```

**テストスクリプトの命名規則**:
- 単体テスト: `[機能名].test.js`
- 統合テスト: `[機能名]-integration.test.js`
- E2Eテスト: `[機能名]-flow.test.js`
- パフォーマンステスト: `[機能名]-performance.test.js`

## テスト品質

**テストの品質基準**:
- **Fast**: テストは高速に実行される
- **Independent**: テストは互いに独立している
- **Repeatable**: テストは同じ結果を生成する
- **Self-validating**: テストは明確にパス/フェイルする
- **Timely**: テストはコードと同時に書かれる

**テストすべき内容**:
- ✅ ハッピーパス
- ✅ エラーケース
- ✅ エッジケース
- ✅ 境界条件
- ✅ 統合ポイント

**テストすべきでない内容**:
- ❌ サードパーティライブラリのコード
- ❌ フレームワークのコード
- ❌ シンプルなゲッター/セッター（クリティカルでない限り）

## 例外・特別なケース

### レガシーコードへの対応

既存のコードベースに導入する場合:
- 新規コードからTDDを適用
- 既存コードは段階的にテストを追加
- カバレッジを段階的に向上

### プロジェクト固有の要件

プロジェクト固有のテスト要件がある場合:
- `.rules/project-specs.md`に記載
- 共通ルールとの差分を明確化
- チーム内で合意形成

## 参考リンク

- [Test-Driven Development (TDD)](https://en.wikipedia.org/wiki/Test-driven_development)
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Testing Best Practices](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

